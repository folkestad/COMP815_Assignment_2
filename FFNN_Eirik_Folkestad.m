% Solve a Pattern Recognition Problem with a Neural Network
% Script generated by Neural Pattern Recognition app
% Created Thu Sep 21 18:48:29 NZST 2017
%
% This script assumes these variables are defined:
%
%   X - input data.
%   T - target data.

% Load data
load('binaryalphadigs.mat')

% Reshape the input in column format (HOPEFULLY CORRECT)
X = zeros(20*16, 36*39);
pos = 1;
for i = 1:size(dat, 1)
    for j = 1:size(dat, 2)
        pixels = dat{i,j}(:);
        for k = 1:size(pixels)
            X(k, pos) = pixels(k);
        end
        pos = pos + 1;
    end
end

% Create one-hot encoded targets in column format
T = zeros(36, 36*39);
value = 1;
for i = 1:36*39
    T(value, i) = 1;
    if mod(i, 39) == 0
        value = value + 1;
    end
end

% Change variable names for the generated feed-forward network script
x = X;
t = T;

% Create a Pattern Recognition Network
hiddenLayerSize = 70;
net = patternnet([hiddenLayerSize]);
% Setup Division of Data for Training, Validation, Testing
net.divideParam.trainRatio = 80/100;
net.divideParam.valRatio = 10/100;
net.divideParam.testRatio = 10/100;
% Train the Network
[net,tr] = train(net,x,t);
% Test the Network
y = net(x);
% e = gsubtract(t,y);
tind = vec2ind(t);
yind = vec2ind(y);
percentErrors = sum(tind ~= yind)/numel(tind);
performance = perform(net,t,y)

% Test split and architecture
% cross_results = zeros(5,20);
% error_results = zeros(5,20);
% for i = 1:5
%     for j = 1:20
%         performances = 0;
%         errors = 0;
%         iterations = 10;
%         for k = 1:iterations
%             % Create a Pattern Recognition Network
%             hiddenLayerSize = j*10;
%             net = patternnet(hiddenLayerSize);
%             % Setup Division of Data for Training, Validation, Testing
%             net.divideParam.trainRatio = (50+(i*5-5))/100;
%             net.divideParam.valRatio = (25-(i*5-5))/100;
%             net.divideParam.testRatio = (25-(i*5-5))/100;
%             % Train the Network
%             [net,tr] = train(net,x,t);
%             % Test the Network
%             y = net(x);
%             e = gsubtract(t,y);
%             tind = vec2ind(t);
%             yind = vec2ind(y);
%             percentErrors = sum(tind ~= yind)/numel(tind);
%             performance = perform(net,t,y)
%             performances = performances + performance;
%             errors = errors + percentErrors;
%         end
%         cross_results(i, j) = performances/iterations;
%         error_results(i, j) = errors/iterations;
%     end
% end
% disp(results)

% Test robustness
% reg_results = zeros(2,20);
% noi_results = zeros(2,20);
% for i = 1:20
%     crossentropy = 0;
%     error = 0;
%     n_crossentropy = 0;
%     n_error = 0;
%     for j = 1:10
%         % Create a Pattern Recognition Network
%         hiddenLayerSize = 70;
%         net = patternnet([hiddenLayerSize]);
%         % Setup Division of Data for Training, Validation, Testing
%         net.divideParam.trainRatio = 80/100;
%         net.divideParam.valRatio = 10/100;
%         net.divideParam.testRatio = 10/100;
%         % Train the Network
%         [net,tr] = train(net,x,t);
%         % Test the Network
%         y = net(x);
%         % e = gsubtract(t,y);
%         tind = vec2ind(t);
%         yind = vec2ind(y);
%         percentErrors = sum(tind ~= yind)/numel(tind);
%         performance = perform(net,t,y)
%         error = error + percentErrors;
%         crossentropy = crossentropy + performance;
% 
%         % Generate new data by flipping random bits
%         noisyX = X(1:end, 1:end);
%         for col = tr.testInd
%             already_flipped = zeros(1,i*5);
%             for random_bit = 1:(i*5)
%                 random_index = randi([1, size(noisyX, 1)]);
%                 while ismember(random_index, already_flipped) 
%                     random_index = randi([1, size(noisyX, 1)]);
%                 end
%                 already_flipped(1, random_bit) = random_index;
%                 noisyX(random_index, col) = mod(noisyX(random_index, col) + 1, 2);
%             end
%         end
% 
%         noisy_y = net(noisyX);
%         tind = vec2ind(t);
%         yind = vec2ind(noisy_y);
%         noisy_percentErrors = sum(tind ~= yind)/numel(tind);
%         noisy_performance = perform(net,t,noisy_y)
%         n_error = n_error + noisy_percentErrors;
%         n_crossentropy = n_crossentropy + noisy_performance;
%     end
%     reg_results(1,i) = crossentropy/10;
%     reg_results(2,i) = error/10;
%     noi_results(1,i) = n_crossentropy/10;
%     noi_results(2,i) = n_error/10;
% end

% Test architecture for robustness
% reg_results = zeros(2,20);
% noi_results = zeros(2,20);
% for i = 1:20
%     crossentropy = 0;
%     error = 0;
%     n_crossentropy = 0;
%     n_error = 0;
%     for j = 1:10
%         % Create a Pattern Recognition Network
%         hiddenLayerSize = i*10;
%         net = patternnet([hiddenLayerSize]);
%         % Setup Division of Data for Training, Validation, Testing
%         net.divideParam.trainRatio = 80/100;
%         net.divideParam.valRatio = 10/100;
%         net.divideParam.testRatio = 10/100;
%         % Train the Network
%         [net,tr] = train(net,x,t);
%         % Test the Network
%         y = net(x);
%         % e = gsubtract(t,y);
%         tind = vec2ind(t);
%         yind = vec2ind(y);
%         percentErrors = sum(tind ~= yind)/numel(tind);
%         performance = perform(net,t,y)
%         error = error + percentErrors;
%         crossentropy = crossentropy + performance;
% 
%         % Generate new data by flipping random bits
%         noisyX = X(1:end, 1:end);
%         for col = tr.testInd
%             already_flipped = zeros(1,20);
%             for random_bit = 1:20
%                 random_index = randi([1, size(noisyX, 1)]);
%                 while ismember(random_index, already_flipped) 
%                     random_index = randi([1, size(noisyX, 1)]);
%                 end
%                 already_flipped(1, random_bit) = random_index;
%                 noisyX(random_index, col) = mod(noisyX(random_index, col) + 1, 2);
%             end
%         end
% 
%         noisy_y = net(noisyX);
%         tind = vec2ind(t);
%         yind = vec2ind(noisy_y);
%         noisy_percentErrors = sum(tind ~= yind)/numel(tind);
%         noisy_performance = perform(net,t,noisy_y)
%         n_error = n_error + noisy_percentErrors;
%         n_crossentropy = n_crossentropy + noisy_performance;
%     end
%     reg_results(1,i) = crossentropy/10;
%     reg_results(2,i) = error/10;
%     noi_results(1,i) = n_crossentropy/10;
%     noi_results(2,i) = n_error/10;
% end

% View the Network
view(net)

% Plots
% Uncomment these lines to enable various plots.
%figure, plotperform(tr)
%figure, plottrainstate(tr)
%figure, plotconfusion(t,y)
%figure, plotroc(t,y)
%figure, ploterrhist(e)

